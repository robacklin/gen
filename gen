#!/bin/sh
#dep: awk grep tr wget git chmod

GEN_VERSION="0.0.$(date +%U).$(date +%H)"
DEF_LANG="cpp"
DEF_RET="int"
DEF_RET_PROC="int"
DEF_CLASS_FUNC_PARAM="(void *p)"
DEF_PROC_FUNC_PARAM="(void *p)"
CLASS_GI=" getInstance m_pInstance "
CLASS_ST=" enter exit transition getEvent setEvent getState setState getName setName m_pName m_nState m_iState m_iNext m_iPrev "
CLASS_DB=" query m_iConnection m_iDatabase m_iTable m_iRow m_iColumn m_pCurrent m_pNext  "
CLASS_TM=" setTimeout getTimeout onTimeout setTimer getTimer m_iTimer "
CLASS_SS=" {TM} start stop run join condWait process worker m_nThread m_iThread m_pThread m_bRun "
CLASS_NET="{TM} connect disconnect listen accept bind select m_pSocket m_iSocket m_iServer m_iClient m_bServer m_bClient m_bInet m_bUnix "
CLASS_SR=" send recv m_pMessage m_nMessage m_iMessage m_iSource m_iDestination m_iRoute "
CLASS_OC=" open close isOpen m_pFile m_iFile m_pHandle m_bOpen "
CLASS_RW=" read write m_pBuffer m_nBuffer m_iBuffer "
CLASS_GS=" get set clear init isEmpty m_iValue m_iSize m_iStatus m_iVersion m_iGroup m_iLevel m_iError m_iType "
CLASS_IO=" {GS}{OC}{RW} "

GEN_PREFIX=gen_
GEN_F_VERSION=${GEN_PREFIX}version.h

c_print_template() {
	lname=${1}
	name=${2}
cat<<EOF
# created on $(date +%F) by $USER
# these are built-in def, only use in classes
EOF
	if [ -n "${GEN_SPEC_CONF}" ] ; then
		cat ${GEN_SPEC_CONF} 
	else
		cat $0 | awk '/^CLASS_/' | sed -e 's/=/} /g' -e 's/CLASS_/# {/g' -e 's/"//g'
	fi
cat<<EOF

# this will create a git repo in the new project 
# and it checkin on every re-run on gen
repo yes

# these are builtin cfgs, you can have more than one options per line
#TODO: options pinout=io i2c=io i2c=packet uart=io spi=io ipc=io

# stubs to generate (cpp|c#|java|qt) currently only c/c++ supported
lang cpp
  	
# in some cases dependency are needed.
# these will download to the 'dl' folder
# dep <URL> <DIRNAME> [<BRANCH>]
dep http://hisham.hm/htop/releases/1.0.3/htop-1.0.3.tar.gz htop-1.0.3
dep https://github.com/acklinr/ip_interface.git ip_interace master

#TODO: pkg <PACKAGENAME> to install
pkg libncursesw5-dev

# import another spec file into project with new filename
# and then to replace key with value in a given spec file
import AnotherSpecFile NewFilename {
	key= replace_with
}
# import spec as is
import MySpecAsIs

# in some cases we need linux driver support
# this will create a stub char driver with its own Makefile
#driver <DRIVER NAME> [<PROC>|<DEF> ...]
driver ${name} my_func1 my_func2

# these are local defines, if prefix given then applied to procedure
# def <VARNAME>= [<PROC> ...]
def rw= open close read write

# def <VARNAME>:<PREFIX>= [<PROC> ...]
def foxy:state_= enter exit trans error event
def csm:Pas= CreateStateMachine
def pas:PasOn= Initialization Destroy Start Stop DebugDump
# another example
# def <VARNAME>:<PREFIX>.<SUFIX>= [<PROC> ...]
def evt1:m_p.Event= Change PressDown PressUp Move Key Touch
# below becomes onChangeEvent
def evt2:on.Event= Change PressDown PressUp Move Key Touch
# below becomes ChangeEvent
def evt3:.Event= Change PressDown PressUp Move Key Touch

# create both header and source for a context
# and place a filename prefix on procedure (ex:${lname}_os_log)
# file <FILENAME> [<PROC>|<VAR>|<DEF> ...]
file unix_os [foxy] m_error log [evt3]
file os_helpers

# NOTE: do NOT creata a file with same name as spec file

# re-define the stub parameters
# par <VARNAME>= <PARAM...> 
par pm= (void* data, int val)

# create both header and soruce for a context
# and allow the parameters to be set
# unlike 'file' ifile does NOT place prefix on procedures 
# ifile <FILENAME> <VARNAME> [<PROC>|<VAR>|<DEF> ...]
ifile Dispatcher {pm} log [pas] m_error [csm]
ifile BlankExample {} [pas] [csm] log
ifile EmptyExample

# creates a file that is included in namespace
# file becomes <FILENAME>_ns.* w/o prefix on procedure
# ns <NAMESPACE PATH:...> <FILENAME> [<PROC>|<VAR>|<DEF> ...]
ns NameSpace1:${name}:MQueue msg_q openQueue closeQueue [foxy] m_err

# test procedure and script are created by default for all class
# but here we add some extra cases we what to check for in main_${lname}.cpp
# test [<TEST_NAME1>|<DEV> ...]
test [rw] file_close bad_filename dbl_close no_filename

# these are the includes that we think we might need
# and they will be copied to each class header and common header
#include <string>
#include <iostream> 

# these are the defines that we think we might need
# and they will be copied to the common header
#define _RELEASE 0

# these are the typedef that we think we might need
# and they will be copied to the common header
# they also allow the code to compile when used by classes
typedef std::string String;

# we need to setup a default return value for class 
# procedures that make use of typedef or structs values
ret String = "hello world";

# these are the structs that we think we might need
# and they will be copied to the common header
struct My${name}Struct { int Val; }; 

# class <CLASSNAME> [<PROC>|<DEF>]
# iclass <CLASSNAME> [<PROC>|<DEF>]
# vclass <CLASSNAME> [<PROC>|<DEF>]
# and/or followed by redefined memebers { ... }

# this class uses a pointer var along with built-in and local def 
class My${name}ClassParent {OC} m_nValue [foxy] {
}

# this class begins with 'I' hence Interface class
class IMy${name}Class {GS} m_isInterfaceClass {
}

# assumes: member var (m_*), pointer (m_p*), bool (m_b*)
# headers are auto included when a class is returned be procedure
# used '\$' for inner class and '@' for enum
class My${name}Class m_iVar MyFunc OurFunc {SR} {
	IMy${name}Class* m_iVar
	String MyFunc OurFunc?open|close
	My${name}Struct* OurFunc m_iVar->get
	\$MyInnerClass myProc1 myProc2
	@eColors RED ORANGE YELLOW
}

# all procedures are virtual in 'iclass'
iclass YourClassIf {IO} m_isInterfaceClass {
}

# example of built-in def
class YourClass {RW} {GI} {
}

# all procedures are 'pure' virtual in 'vclass'
# and all member var are dropped
vclass PureVirtualClass [rw] m_pInterface {
}

# here we re-order the class inheritance
# order [<CLASSMAP>...]
order My${name}Class:My${name}ClassParent YourClass:My${name}ClassParent
order My${name}ClassParent:IMy${name}Class

# express a usage of a class doc/yourclass.ref
# expr NAME <USING>
expr YourClass My${name}Class {
	YourClass *p = YourClass();
	p->HelloWorld(new  My${name}Class);
}

#eof v${GEN_VERSION}
EOF
}

removeleadingstr() {
	sed -e "s/^${1}//g"
}
ltrim() {
	sed -e 's/[ \t]*$//'
}
ignore() {
	awk '!/^#/'
}
keyword_options() {
	if [ -n "${1}" ] ; then
		awk "/^options\s${1}/"
	else
		awk '/^options\s/'
	fi
}
keyword_repo() {
	if [ -n "${1}" ] ; then
		awk "/^repo\s${1}/"
	else
		awk '/^repo\sy/'
	fi
}
keyword_dep() {
	if [ -n "${1}" ] ; then
		awk "/^dep\s${1}/"
	else
		awk '/^dep\s/'
	fi
}
keyword_pkg() {
	if [ -n "${1}" ] ; then
		awk "/^pkg\s${1}/"
	else
		awk '/^pkg\s/'
	fi
}
keyword_def() {
	if [ -n "${1}" ] ; then
		awk "/^def\s${1}/"
	else
		awk '/^def\s/'
	fi
}
keyword_par() {
	if [ -n "${1}" ] ; then
		awk "/^par\s${1}=\s/"
	else
		awk '/^par\s/'
	fi
}
keyword_ifile() {
	if [ -n "${1}" ] ; then
		awk "/^ifile\s${1}/"
	else
		awk '/^ifile\s/'
	fi
}
keyword_file() {
	if [ -n "${1}" ] ; then
		awk "/^file\s${1}/"
	else
		awk '/^file\s/'
	fi
}
keyword_driver() {
	if [ -n "${1}" ] ; then
		awk "/^driver\s${1}/"
	else
		awk '/^driver\s/'
	fi
}
keyword_order() {
	if [ -n "${1}" ] ; then
		awk "/^order\s${1}/"
	else
		awk '/^order\s/'
	fi
}
keyword_ret() {
	if [ -n "${1}" ] ; then
		awk "/^ret\s${1}/"
	else
		awk '/^ret\s/'
	fi
}
keyword_include() {
	if [ -n "${1}" ] ; then
		awk '/^#include\s/' ${1}
	else
		awk '/^#include\s/'
	fi
}
keyword_class() {
	if [ -n "${1}" ] ; then
		awk "/^class\s${1}/"
	else
		awk '/^class\s|^iclass|^vclass\s/'
	fi
}
keyword_expr() {
	if [ -n "${1}" ] ; then
		awk "/^expr\s${1}/"
	else
		awk '/^expr\s/'
	fi
}
keyword_import() {
	if [ -n "${1}" ] ; then
		awk "/^import\s${1}/"
	else
		awk '/^import\s/'
	fi
}
replace() {
	if [ -n "${3}" ] ; then
		echo "${3}" | sed -e "s,${1},${2},g"
	else
		sed -e "s,${1},${2},g"
	fi
}
replace_str() {
	sed -e "s/${1}/${2}/g"
}
replace_in_file() {
	sed -i "s,${1},${2},g" ${3}
}
class_members() {
	 awk "/^class\s${2}\s/ {flag=1;next} /^class\s/{flag=0} flag {print}" 
}
tolower() {
	if [ -n "${1}" ] ; then
		echo "${1}" | tr '[:upper:]' '[:lower:]'
	else
		tr '[:upper:]' '[:lower:]'
	fi
}
toupper() {
	if [ -n "${1}" ] ; then
		echo "${1}" | tr '[:lower:]' '[:upper:]'
	else
		tr '[:lower:]' '[:upper:]'
	fi
}
clearfile() {
	echo -n > $1
}
order_parentclass() {
	if [ -n "${1}" ] ; then
		echo "${1}" | awk -F':' '{print $2}'
	else
		awk -F':' '{print $2}'
	fi
}
is_variable() {
	echo "${1}" | grep "^m_" 2>&1 > /dev/null
	echo "$?"
}
is_variable_ptr() {
	echo "${1}" | grep "^m_p" 2>&1 > /dev/null
	echo "$?"
}
is_variable_bool() {
	echo "${1}" | grep "^m_b" 2>&1 > /dev/null
	echo "$?"
}
is_variable_other() {
	echo "${1}" | grep "^m_" 2>&1 > /dev/null
	echo "$?"
}
list_compress() {
cat<<EOF
.tar.gz
.zip
.tar
.tar.bz
.tar.xz
EOF
}
is_compress() {
	bname=$(basename ${1})
	for x in $(list_compress) ; do
		echo "${bname}" | grep "$x" 2>&1 > /dev/null
		if [ "$?" = "0" ] ; then
			echo "0"
			return
		fi
	done
	echo "1"
}

c_print_testfunc_grp() {
cat<<EOF

int test_${1}(int argc, char **argv)
{
EOF
	for fn in `echo ${2}`; do
		if [ "$(is_variable ${fn})" != "0" ] ; then
			lfn=$(tolower ${fn})
cat<<EOF
	/* TESTME( ${fn}${3}, RETURN ) */
EOF
		fi
	done
cat<<EOF
	LOG_TRACE("test ${1}");
	return 0;
}
EOF
}

c_print_testfunc() {
	if [ "${4}" = "vclass" ] ; then
		return
	fi
	if [ -n "${2}" ] ; then
cat<<EOF

int test_${1}(int argc, char **argv)
{
	${2} *${1} = new ${2};
	LOG_TRACE("test ${2}");
	/* ${3} */
	delete ${1};
	return 0;
}
EOF
	else
cat<<EOF

int test_${1}(int argc, char **argv)
{
	LOG_TRACE("test ${1}");
	return 0;
}
EOF
	fi
}

sh_print_version() {
cat<<EOF
#!/bin/sh
YEAR=$(date +%g)
echo \"\$((\$(date +%g)-\$YEAR)).\$(date +%U).\$(date +%w).\$(date +%H)\" 
EOF
}

sh_print_testfunc() {
	cname=${1}
	lpname=${2}
cat<<EOF
#!/bin/sh
# created on $(date +%F) by $USER

which valgrind 2>&1 > /dev/null
if [ "x\$?" != "x0" ] ; then
	echo "valgrind not found in path"
	echp "apt-get install valgrind"
	exit 1
fi

export LD_LIBRARY_PATH=$(pwd)/lib:\$LD_LIBRARY_PATH
echo "test ${cname} begin: \$0"
EOF
	if [ -r ".test_up" ] ; then
		cat ${3}.test_up
	else
		echo "# ${3}/.test_up found found"
	fi
cat<<EOF
valgrind --leak-check=yes --log-file=out/${cname}.out bin/${lpname} -test=${cname}
EOF
	if [ -r ".test_down" ] ; then
		cat ${3}/.test_down
	else
		echo "# ${3}/.test_down found found"
	fi
cat<<EOF
echo "test ${cname} end: \$0"

#EOF
EOF
}

c_print_comment() {
	file=$(tolower ${1})
cat<<EOF
/* created on: $(date +%F) by ${USER} */ 
/* file: ${file} */

EOF
}

c_spec_main_body() {
	lpname=${1}
	cname="common"
#	upname=$(toupper ${lpname})
	c_print_comment "${cname}.cpp"

cat<<EOF

#include <cstring>
#include "${GEN_F_VERSION}"
#include "${GEN_PREFIX}${lpname}.h"
#include "${lpname}global.h"

#define TESTME( FUN_F, RET_V ) \\
	if (FUN_F == RET) { \\
		LOG_TRACE("OK"); \\
	} else { \\
		LOG_TRACE("FAILED"); \\
	}
EOF
	f_listclass ${SPEC_FILE} | while read class name other ; do
		lname=$(tolower $name)
		ltest=$(tolower "test/test_${lname}")
		c_print_testfunc "${lname}" "${name}" "${other}" "${class}"
		sh_print_testfunc ${name} ${lpname} "test" > $ltest
		chmod a+x $ltest
	done
	f_listtest_raw ${SPEC_FILE} | while read f_test; do
		if [ -n "$f_test" ] ; then
			for name in `echo $f_test`; do
				lname=$(tolower ${name})
				c_print_testfunc ${lname}
			done
		fi
	done
	f_listfile_raw  ${SPEC_FILE} | while read name flist; do 
		if [ -n "${flist}" ] ; then
			lname=$(tolower ${name})
			c_print_testfunc_grp "${lname}" "${flist}" "()"
		fi
	done
	f_listifile_raw  ${SPEC_FILE} | while read name cmd flist; do 
		if [ -n "${flist}" ] ; then
			lname=$(tolower ${name})
			lcmd=$(echo "${cmd}" | sed -e 's/{//g' -e 's/}//g' )
			c_print_testfunc_grp "${lname}" "${flist}" "(${lcmd})"
		fi
	done
	f_listnsfile_raw  ${SPEC_FILE} | while read nspace name flist; do 
		if [ -n "${flist}" ] ; then
			lname=$(tolower ${name})
			c_print_testfunc_grp "${lname}" "${flist}" "()"
		fi
	done
cat<<EOF

${pname}Global g_Global;

typedef struct ${lpname}_map
{
	const char *pStr;
	int(*fn)(int, char**);
	int nRun;
} ${upname}_MAP;

int main(int argc, char** argv)
{
	int nIdx = 0;
	const ${upname}_MAP list[] = { /* list of test procedures */
EOF

	f_listclass ${SPEC_FILE} | while read class name other ; do
		if [ "${class}" != "vclass" ] ; then
			lname=$(tolower ${name})
			echo "		{\"-test=${name}\", &test_${lname}, 1},"
		fi
	done
	f_listtest_raw ${SPEC_FILE} | while read f_test; do
		if [ -n "$f_test" ] ; then
			for name in `echo $f_test`; do
				lname=$(tolower ${name})
				echo "		{\"-test=${lname}\", &test_${lname}, 0},"
			done
		fi
	done
	f_listfile_raw ${SPEC_FILE} | while read name f_test; do
		if [ -n "$f_test" ] ; then
			lname=$(tolower ${name})
			echo "		{\"-test=${lname}\", &test_${lname}, 0},"
		fi
	done
	f_listifile_raw ${SPEC_FILE} | while read name lcmd f_test; do
		if [ -n "$f_test" ] ; then
			lname=$(tolower ${name})
			echo "		{\"-test=${lname}\", &test_${lname}, 0},"
		fi
	done
	f_listnsfile_raw ${SPEC_FILE} | while read nsspace name f_test; do
		if [ -n "$f_test" ] ; then
			lname=$(tolower ${name})
			echo "		{\"-test=${lname}\", &test_${lname}, 0},"
		fi
	done

cat<<EOF
		{0, 0, 0}
	};
	LOG_TRACE("build:" << ${upname}_VERSION 
			<< " rev:" << ${upname}_REVISION);
	LOG_TRACE("begin test (" << argc << ")");
	while((list[nIdx].pStr != 0) && (argc > 1))
	{
		if((strcmp(argv[1], list[nIdx].pStr) == 0) && (list[nIdx].nRun != 0))
			return list[nIdx].fn(argc, argv);
		nIdx++;
	}
	LOG_TRACE("end test (" << argv[0] << ")");

	return argc;
}	
EOF
}

c_spec_common_header() {
	lpname=${1}
	cname="common"
	c_print_comment "${lpname}${cname}.h"
	c_print_header_begin ${lpname} ${cname}
	keyword_include ${SPEC_FILE}
#	awk '/^#include\s/' ${SPEC_FILE} 
cat<<EOF

#include <iostream>

#define LOG_TRACE(VAR_A) std::cout << "[TRACE] (" << __FUNCTION__ << ":" << __LINE__ << ") " << VAR_A << std::endl; 

EOF
	echo "/* define common section */" 
	awk '/^#define\s/' ${SPEC_FILE} 
	echo "" 
	echo "/* typedef common section */" 
	awk '/^typedef\s/' ${SPEC_FILE}
	echo "" 
	echo "/* struct common section */" 
	awk '/^struct\s/' ${SPEC_FILE}
	echo "" 
	c_print_header_end ${lpname} ${cname}
}

c_spec_body() {
	pfile="${1}"
	cname="${2}"
	file="${3}"
	other="${4}"
	keyw="${5}"
	lcname=$(tolower "${cname}")
	c_print_comment "${lcname}.cpp"
cat<<EOF

#include "${lcname}.h"

EOF
	if [ "${keyw}" = "vclass" ] ; then
		return
	fi
	c_print_ctor ${cname} "ctor-${cname}"
	c_print_dtor ${cname} "dtor-${cname}"
	for f in `echo ${other}` ; do
		if [ "$(is_variable ${f})" != "0" ] ; then
			rm -f /tmp/found_lock 2>&1 > /dev/null
			f_listmembers ${SPEC_FILE} ${cname} | awk "/${f}/" | while read f_ret f_memb f_calls ; do
				if [ "$f_memb" = "${f}" ] ; then
					c_print_member "${f_ret}" "${cname}" "${f}" "${f_calls}" "${other}"
					touch /tmp/found_lock
					break
				fi
			done
			if [ ! -r "/tmp/found_lock" ] ; then
				c_print_member "${DEF_RET}" "${cname}" "${f}" "${f_calls}" "${other}"
			fi
		fi
	done
}

c_spec_print_includes() {
	cname=${1}
	pname=${2}
	prev_lname=""
	f_listclass ${SPEC_FILE} | sort -u | awk '{print $2}' > $TMPDIR/${pname}.tmp
	f_listmembers ${SPEC_FILE} ${cname} | while read f_ret f_memb f_calls ; do
		if [ -n "${f_ret}" ] ; then
#			egrep "${f_ret}\$" $TMPDIR/${pname}.tmp 2>&1 > /dev/null
			egrep "^${f_ret}\$" $TMPDIR/${pname}.tmp 2>&1 > /dev/null
#			awk "/^${f_ret}\$/" $TMPDIR/${pname}.tmp 2>&1 > /dev/null
			if [ "$?" = "0" ] ; then
				lname=$(tolower ${f_ret})
				if [ "${prev_lname}" != "${lname}" ] ; then
					echo "#include \"$(echo "${lname}" | sed -e 's/\*//g' ).h\""
				fi
				prev_lname="${lname}"
			fi
		fi
	done
	rm $TMPDIR/${pname}.tmp
}

c_spec_header() {
	pname=${1}
	cname=${2}
	text=${3}
	other=${4}
	keyw=${5}
	lpname=$(tolower ${pname})
	c_print_comment ${text}
	c_print_header_begin ${pname} ${cname}
	awk '/^#include\s/' ${SPEC_FILE} 
	echo "#include \"${lpname}common.h\""
	c_spec_print_includes  "${cname}" "${pname}"
	c_spec_header_class_body "${cname}" "${pname}" "${other}" "${keyw}"
	c_print_header_end "${pname}" "${cname}"
}

c_spec_header_class_begin() {
	cname=${1}
	pname=${2}
	parent=${3}
	lang=${DEF_LANG}
# qt Q_OBJECT public slots:
	if [ "${lang}" = "cpp" ] ; then
cat<<EOF
class ${cname} : public ${parent}
{
public:
EOF
	else
cat<<EOF
class ${cname} : public QObject
{
	Q_OBJECT
	//Q_PROPERTY(bool hasConnection READ hasConnection NOTIFY hasConnectionChanged)
public:
EOF
	fi
}

c_print_enum_class() {
	cname=${1}
	other=${2}
	f_listmembers "${SPEC_FILE}" "${cname}" | awk "/\s@/" | sed -e 's/@//g' | while read klass kmembers ; do
		if [ -n "${klass}" ] ; then
cat<<EOF

	enum ${klass} /**< enum ${klass} */
	{
EOF
	for fn in `echo "${kmembers}"` ; do
cat<<EOF
		${fn},
EOF
	done
cat<<EOF
	};
EOF
		fi
	done
}

c_print_inner_class() {
	cname=${1}
	other=${2}
	f_listmembers "${SPEC_FILE}" "${cname}" | awk "/\s\\$/" | sed -e 's/\$//g' | while read klass kmembers ; do
		if [ -n "${klass}" ] ; then
cat<<EOF

	class ${klass}  /**< inner class ${klass} */
	{
	public:
		${klass}();
		~${klass}();
EOF
	for fn in `echo "${kmembers}"` ; do
cat<<EOF
		int ${fn}(void* p)
		{
			return 0;
		};
EOF
	done
cat<<EOF
	};
EOF
		fi
	done
}

c_spec_header_class_body()
{
	cname=${1}
	pname=${2}
	other=${3}
	keyw=${4}
	parent="$(f_listorder "${SPEC_FILE}" "${pname}" "${cname}")"
	if [ -n "${parent}" ] ; then
		if [ "${parent}" != "${cname}" ] ; then
			lparent=$(tolower ${parent})
			echo "#include \"${lparent}.h\""
		fi
	fi
	echo "" 
	echo "typedef void* ptr${cname}Type;" 
	echo "" 
	c_spec_header_class_begin "${cname}" "${pname}" "${parent}"
	echo "${cname}" | egrep "^I" 2>&1 > /dev/null
	if [ "$?" = 0 ] ; then
		virt="virtual "
		keyw="iclass"
	fi
	if [ "${keyw}" = "vclass" ] ; then
		virt="virtual "
	fi
cat<<EOF
	${cname}();
	${virt}~${cname}();
	$(c_print_inner_class "${cname}" "${other}")
	$(c_print_enum_class "${cname}" "${other}")
EOF
	ret="${DEF_RET}"
	param=""
	text="unknown"
	pvirt=""
	for fname in `echo ${other}` ; do
		text="function"
#param=${DEF_CLASS_FUNC_PARAM}
		param="(ptr${cname}Type data)"
		ret="${DEF_RET}"
		if [ "${keyw}" = "iclass" ] ; then
			virt="virtual "
		fi
		if [ "${keyw}" = "vclass" ] ; then
			virt="virtual "
			pvirt=" = 0"
		fi
		if [ "$(is_variable ${fname})" = "0" ] ; then
			text="variable"
			ret="int"
			param=""
			virt=""
		fi
		if [ "$(is_variable_ptr ${fname})" = "0" ] ; then
			text="pointer"
			ret="void*"
			param=""
			virt=""
		fi
		if [ "$(is_variable_bool ${fname})" = 0 ] ; then
			text="variable"
			ret="bool"
			param=""
			virt=""
		fi
		newret=$(f_listmembers ${SPEC_FILE} ${cname} | awk '{print $2, $1}' | egrep "^${fname}\s" | awk '{print $2}' | sort | head -1)
		if [ -n "$newret" ] ; then
			ret=${newret}
			virt=""
		fi
cat<<EOF
	${virt}${ret} ${fname}${param}${pvirt}; /**< ${fname} ${virt}member ${text} */
EOF
	done
	c_spec_header_class_end
	echo "" 
}

c_spec_header_class_end() {
	lang=${DEF_LANG}
	if [ "${lang}" = "cpp" ] ; then
cat<<EOF

protected:

private:

};
EOF
	else
cat<<EOF

signals:

protected:

private:

};
EOF
	fi
}

c_print_header_begin() {
	upname=$(toupper ${1})
	ucname=$(toupper ${2})
cat<<EOF
#pragma once
#ifndef ${upname}_${ucname}_H_
#define ${upname}_${ucname}_H_

EOF
}

c_print_header_end() {
	echo "#endif /* $(toupper "${1}")_$(toupper "${2}")_H_ */"
	echo ""
}

c_remove_parent() {
	pname="${1}"
	file="${2}"
	sed -i "s/: public ${pname}Object//" "${file}"
}

c_print_cfunc() {
	ret=${1}
	name=${2}
	param=${3}
	if [ -n "${5}" ] ; then
cat<<EOF

/* ${4} */
$ret ${name}${param}
{
	${5}
	${6}
	return 0;
}
EOF
	else
cat<<EOF

/* ${4} */
$ret ${name}${param}
{
	return 0;
}
EOF
	fi
}

c_print_ctor() {
cat<<EOF
${1}::${1}()
{
		LOG_TRACE(" ${2} ");
}

EOF
}

c_print_dtor() {
cat<<EOF
${1}::~${1}()
{
		LOG_TRACE(" ${2} ");
}

EOF
}

c_print_member() {
	ret=${1}
	cname=${2}
	fname=${3}
	fcalls=${4}
	other=${5}
	desc=${fname}
	param="inputVar"
	if [ "x$(echo "${fcalls}" | wc -c)" = "x1" ] ; then
		fcalls=${other}
	fi
	c_print_dox "${desc}" "${param}" "${ret}"
	val="return"
	case "${ret}" in
	bool)
		val="return true"
	;;
	int)
		val="return 0"
	;;
	std::string)
		val="return \"hello\""
	;;
	char)
		val="return 0"
	;;
	bool)
		val="return true"
	;;
	void)
		val="return"
	;;
	*)
		def=$(f_listdefault "${SPEC_FILE}" "$ret")
		if [ -n "${def}" ] ; then
			val="${ret} var =${def} return var"
		else
			echo "${ret}" | egrep "\*" 2>&1 > /dev/null
			if [ "$?" = "0" ] ; then
				val="${ret} var = nullptr; return var"
			else
				val="${ret} var; return var"
			fi
		fi
	;;
  	esac	

#	def_param="${DEF_CLASS_FUNC_PARAM}"
	def_param="(ptr${cname}Type data)"
cat<<EOF
${ret} ${cname}::${fname}${def_param}
{
		LOG_TRACE(" enter ");
		/* ${fcalls} */	
		LOG_TRACE(" exit ");
		${val};
}

EOF
}

c_print_dox() {
cat<<EOF
/**
 * @desc ${1}
 * @param ${2}
 * @return ${3}
 */
EOF
}	
run_wget() {
	url=${1} 
	outfile=${2} 
	if [ -n "${outfile}" ] ; then
		mkdir -p dl/${outfile}
		OUT=dl/${outfile}/$(basename $url)
		if [ ! -r "$OUT" ] ; then
			wget $url -O $OUT || rm $OUT
		else
			echo "already downloaded $OUT"
		fi
	else
		echo "malformed wget command"
	fi
}
gitignore() {
cat<<EOF > .gitignore
bin/*
dl/*
lib/*
obj/*
out/*
EOF
}
process_repo() {
	file=${1}
	pname=${2}
	cat ${file} | keyword_repo | while read keyw repo; do
		if [ -n "${keyw}" ] ; then
			if [ ! -d ".git" ] ; then
				git init
				git add --ignore-removal bin/ obj/ out/ lib/
				gitignore
				git add ./
				git commit -a -m "initial commit" 2>&1 > /dev/null
			else
				git add ./
				git commit -a -m "${pname}: spec updates $(date +%F) $(date +%T)" 2>&1 > /dev/null
			fi
		else
			echo "malformed repo command"
		fi
	done
}
run_git() {
	url=${1}
	outdir=${2}
	branch=${3}
	if [ -n "${outdir}" ] ; then
		OUT=dl/${outdir}
		if [ ! -d "$OUT" ] ; then
			mkdir -p ${OUT}
			if [ -n "${branch}" ] ; then
				git clone -b ${branch} ${url} ${OUT}
			else
				git clone $url ${OUT}
			fi
		else
			echo "already downloaded $OUT"
		fi
	else
		echo "malformed git command"
	fi
}
process_dep() {
	cat $file | keyword_dep | while read keyw url odir branch misc ; do
		if [ "$(is_compress ${url})" = "0" ] ; then
#			echo "is compress ${url}"
			run_wget "${url}" "${odir}"
		else
#			echo "is not compress ${url}"
			run_git "${url}" "${odir}" "${branch}"
		fi	
	done
}
process_pkg() {
#	getOSInstallType
	cat $file | keyword_pkg | while read keyw url odir branch misc ; do
		echo "[package] ${url}"
	done
}
process_test() {
	file=${1}
	pname=${2}
	lpname=${3}
	f_listtest_raw ${file} | while read f_test; do
		if [ -n "$f_test" ] ; then
			for name in `echo $f_test`; do
				sfile=$(tolower "test/test_${name}")
				lname=$(tolower ${name})
				echo "[test] creating ${sfile} for ${lname}"
cat<<EOF > ${sfile}
#!/bin/sh
# created on $(date +%F) by $USER
# test place holder

export LD_LIBRARY_PATH=$(pwd)/lib:\$LD_LIBRARY_PATH

echo "test ${name} begin: \$0"
valgrind --leak-check=yes --log-file=out/${name}.out bin/${lpname} -test=${name}
echo "test ${name} end: \$0"

#eof
EOF
			chmod a+x ${sfile}
			done
		fi
	done
}

f_print_drv_h_includes() {
cat<<EOF
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/sched.h>
#include <linux/init.h>
#include <linux/slab.h>
#include <linux/device.h>
#include <linux/miscdevice.h>
EOF
}

f_print_drv_c_includes() {
cat<<EOF
#include <linux/module.h>
#include <linux/interrupt.h>
EOF
}

f_print_nspace_begin() {
	nspace=${1}
	echo ""
	for ns in `echo ${nspace} | sed -e 's/:/ /g'` ; do
cat<<EOF 
namespace ${ns} {
EOF
	done
	echo ""
}

f_print_nspace_end() {
	nspace=${1}
	echo ""
	for ns in `echo ${nspace} | sed -e 's/:/ /g' | awk '{ for (i=NF; i>=1; i--) printf (i!=1) ? $i OFS : $i "\n" }'` ; do
cat<<EOF
} /* namespace: ${ns} */
EOF
	done
	echo ""
}

process_nsfile() {
	file=${1}
	pname=${2}
	lpname=${3}
	phfile=${4}
	f_listnsfile_raw ${file} | while read nspace name f_proc; do
		if [ -n "$name" ] ; then
			lname=$(tolower ${name})
			uname=$(toupper ${name})
			hfile=$(tolower "include/${lname}_ns.h")
			cfile=$(tolower "src/${lname}_ns.cpp")

			echo "[ns] creating file ${hfile}" 
			clearfile ${hfile}
			clearfile ${cfile}
			c_print_comment "${name}.h" >> ${hfile}
			c_print_header_begin ${upname} ${name} >> ${hfile}

cat<<EOF >> ${hfile}
#include "${lpname}common.h"

#define ${uname}_NSPATH "$(echo ${nspace} | sed -e 's,:,/,g')"
#define ${uname}_DOTPATH "$(echo ${nspace} | sed -e 's,:,.,g')"

typedef void* ${name}_t;
EOF
			c_print_comment "${name}.cpp" >> ${cfile}
			echo "#include \"$(basename ${hfile})\"" >> ${phfile}
			echo "#include \"$(basename ${hfile})\"" >> ${cfile}
			f_print_nspace_begin "${nspace}" >> ${hfile}
			f_print_nspace_begin "${nspace}" >> ${cfile}
			for fn in `echo $f_proc`; do
cat<<EOF >> ${hfile}
${name}_t ${fn}_data;
EOF
			done
			echo "" >> ${hfile}
#			param="${DEF_PROC_FUNC_PARAM}"
			param="(${name}_t handle, int num, void *data)"
			for fn in `echo $f_proc`; do
				if [ "$(is_variable ${fn})" = "0" ] ; then
					echo -n
				else
					xmt="commit"
					xmt_t="/* ${fn}_data = 0; */"
					xmt_v="/* */"
					echo "${DEF_RET_PROC} ${fn}${param};" >> ${hfile}
#				echo "[ns] creating file $hfile for function ${fn}" 
					c_print_cfunc "${DEF_RET_PROC}" "${fn}" "${param}" "${xmt}" "${xmt_t}" "${xmt_v}" >> ${cfile}
				fi
			done
			f_print_nspace_end "${nspace}" >> ${cfile}
			f_print_nspace_end "${nspace}" >> ${hfile}
			c_print_header_end ${upname} ${name} >> ${hfile}
			mf_print_gcc "${lname}" "${cfile}" "$MF"
		fi
	done
}

process_ifile() {
	file=${1}
	pname=${2}
	lpname=${3}
	phfile=${4}
	specf=${file}
	f_listifile_raw ${file} | while read name parm f_proc; do
		if [ -n "$name" ] ; then
			hfile=$(tolower "include/${name}.h")
			cfile=$(tolower "src/${name}.cpp")
			lname=$(tolower ${name})
			xname=${name}
			echo "[ifile] creating file ${hfile}" 
			echo "#include \"${lname}.h\"" >> ${phfile}

			clearfile ${hfile}
			clearfile ${cfile}
			c_print_comment "${name}.h" >> ${hfile}
			c_print_header_begin ${upname} ${name} >> ${hfile}
			c_print_comment "${name}.cpp" >> ${cfile}

cat<<EOF >> ${cfile}
#include "${lname}.h"
EOF

cat<<EOF >> ${hfile}
#include "${lpname}common.h"

/* context typedef stub */
typedef void* ${lname}_${lpname};

/* context struct stub */
typedef struct ${lname}_tag
{
	int ${lname}_id;
	${lname}_${lpname} ${lname};
	/* add stuff here */
EOF
			for fn in `echo $f_proc`; do
cat<<EOF  >> ${hfile}
	${lname}_${lpname} ${fn}_data; /* ${fn} data */
EOF
			done
cat<<EOF  >> ${hfile}
} ${lname}_t, *${lname}_ptr;

EOF
			xparm=""
			if [ -n "${parm}" ] ; then
#				echo "1par(${parm})"
				xparm=$(echo "${parm}" | sed -e 's/{//g' -e 's/}//g')
#				echo "2par(${xparm})"
				if [ -n "${xparm}" ] ; then
					xparm=$(f_listpar "${specf}" "${xparm}"|head -1)
#					echo "3par($(f_listpar "${specf}" "${xparm}"))"
#					echo "4par(${xparm})"
				fi
			fi
			if [ ! -n "${xparm}" ] ; then
				xparm="(${lname}_ptr handle, int num, void *data)"
				hdl="handle->"
			fi
			for fn in `echo $f_proc`; do
				if [ "$(is_variable ${fn})" = "0" ] ; then
					echo -n
				else
					xmt="@func of ${fn}"
					xmt_t="/* ${hdl}${fn}_data = 0; */"
					xmt_v="/**/"
					echo "${DEF_RET_PROC} ${fn}${xparm};" >> ${hfile}
#				echo "[ifile] creating file $hfile for function ${fn}" 
					c_print_cfunc "${DEF_RET_PROC}" "${fn}" "${xparm}" "${xmt}" "${xmt_t}" "${xmt_v}" >> ${cfile}
				fi
			done
			echo "" >> ${cfile}
			echo "" >> ${hfile}
			c_print_header_end ${upname} ${xname} >> ${hfile}
			mf_print_gcc "${lname}" "${cfile}" "$MF"
		fi
	done
}

process_import() {
	file=${1}
	pname=${2}
	lpname=${3}
	phfile=${4}
	f_listimport ${file} | while read name as_name f_proc; do
		if [ ! -r "import/${name}/${name}.spec" ] ; then
			mkdir -p import/${name}
			if [ -r "${GEN_SPEC_HOME}/${name}.spec" ] ; then
				echo "[import] ${name}.spec"
				cp -f ${GEN_SPEC_HOME}/${name}.spec import/${name}/
				echo "TODO: cd dl/${name}/ && gen ${name}"
			else
				echo "[import] FAILED: ${name}.spec"
				cd import/${name} ; gen ; mv Hello.spec ${name}.spec ; cd -
			fi
		else
			echo "[import] ${name}.spec already imported"
		fi
	done
}

process_file() {
	file=${1}
	pname=${2}
	lpname=${3}
	phfile=${4}
	f_listfile_raw ${file} | while read name f_proc; do
		if [ -n "$name" ] ; then
			hfile=$(tolower "include/${name}.h")
			cfile=$(tolower "src/${name}.cpp")
			lname=$(tolower ${name})
			xname=${name}
			echo "[file] creating file ${hfile}" 
			echo "#include \"${lname}.h\"" >> ${phfile}

			clearfile ${hfile}
			clearfile ${cfile}
			c_print_comment "${name}.h" >> ${hfile}
			c_print_header_begin ${upname} ${name} >> ${hfile}
			c_print_comment "${name}.cpp" >> ${cfile}

cat<<EOF >> ${cfile}
#include "${lname}.h"
EOF

cat<<EOF >> ${hfile}
#include "${lpname}common.h"

/* context typedef stub */
typedef void* ${lname}_${lpname};

/* context struct stub */
typedef struct ${lname}_tag
{
	int ${lname}_id;
	${lname}_${lpname} ${lname};
	/* add stuff here */
EOF
			for fn in `echo $f_proc`; do
cat<<EOF  >> ${hfile}
	${lname}_${lpname} ${fn}; /* ${fn} data */
EOF
			done
cat<<EOF  >> ${hfile}
} ${lname}_t, *${lname}_ptr;

EOF

			param="(${lname}_ptr handle, int num, void *data)"
			for fn in `echo $f_proc`; do
				if [ "$(is_variable ${fn})" = "0" ] ; then
					echo -n
				else
					xmt="@func of ${fn}, context of ${xname}; (in:handle, in:num, io:data)"
					xmt_t="/* if ((handle == 0) || (date == 0)) return 0; */"
					xmt_v="/* handle->${fn} = 0; */"
					echo "${DEF_RET_PROC} ${xname}_${fn}${param};" >> ${hfile}
#				echo "[file] creating file $hfile for function ${fn}" 
					c_print_cfunc "${DEF_RET_PROC}" "${xname}_${fn}" "${param}" "${xmt}" "${xmt_t}" "${xmt_v}" >> ${cfile}
				fi
			done
			echo "/* eof ${cfile} */" >> ${cfile}

			echo "" >> ${hfile}
			c_print_header_end ${upname} ${xname} >> ${hfile}
			mf_print_gcc "${lname}" "${cfile}" "$MF"
		fi
	done
}

process_chdrv() {
	file=${1}
	pname=${2}
	lpname=${3}
	chpath="driver/char"
	f_listchdrv_raw ${file} | while read name f_proc; do
		if [ -n "$name" ] ; then
			mkdir -p ${chpath}
			hfile=$(tolower "${chpath}/${name}.h")
			cfile=$(tolower "${chpath}/${name}.c")
			lname=$(tolower ${name})
			uname=$(toupper ${name})

			clearfile ${hfile}
			clearfile ${cfile}
			c_print_comment "${name}.h" >> ${hfile}
			c_print_header_begin ${upname} ${name} >> ${hfile}
			c_print_comment "${name}.cpp" >> ${cfile}

cat<<EOF >> ${hfile}
$(f_print_drv_h_includes)

#define ${uname}_NAME "${lname}"

EOF
cat<<EOF >> ${cfile}
$(f_print_drv_c_includes)

#include "$(basename ${hfile})"

static struct device *${lname}_dev;
static char *ramdisk;
static size_t ramdisk_size = (16 * PAGE_SIZE);

static const struct file_operations ${lname}_fops;

/* #define MAXIRQS 256 */
#define MAXIRQS nr_irqs

#define NCOPY (MAXIRQS * sizeof(int))

static int *interrupts;

static irqreturn_t ${lname}_interrupt(int irq, void *dev_id)
{
	interrupts[irq]++;
	return IRQ_NONE;	/* we return IRQ_NONE because we are just observing */
}

static void freeup_irqs(void)
{
	int irq;
	for (irq = 0; irq < MAXIRQS; irq++) {
		if (interrupts[irq] >= 0) {	/* if greater than 0, was able to share */
			synchronize_irq(irq);
			dev_info(${lname}_dev,
				 "Freeing IRQ= %4d, which had %10d events\n",
				 irq, interrupts[irq]);
			free_irq(irq, interrupts);
		}
	}
}

static void get_irqs(void)
{
	int irq;
	interrupts = (int *)ramdisk;

	for (irq = 0; irq < MAXIRQS; irq++) {
		interrupts[irq] = -1;	/* set to -1 as a flag */
		if (!request_irq
		    (irq, ${lname}_interrupt, IRQF_SHARED, "${lname}_int", interrupts)) {
			interrupts[irq] = 0;
			dev_info(${lname}_dev, "Succeded in registering IRQ=%d\n",
				 irq);
		}
	}
}
EOF
			param="(void *p)"
			ret="static inline int"
			for fn in `echo "${f_proc}"`; do
				if [ "$(is_variable ${fn})" = "0" ] ; then
					echo -n
				else
					xmt="commit"
					xmt_t="/* ${fn}_data = 0;"
					xmt_v="*/"
					echo "${ret} ${lname}_${fn}${param};" >> ${hfile}
					echo "[driver] creating file $hfile for function ${fn}" 
					c_print_cfunc "${ret}" "${lname}_${fn}" "${param}" "${xmt}" "${xmt_t}" "${xmt_v}" >> ${cfile}
				fi
			done
cat<<EOF >> ${cfile}

static inline int ${lname}_open(struct inode *inode, struct file *file)
{
	static int counter;
	dev_info(${lname}_dev, " attempting to open device: %s:\n", ${uname}_NAME);
	dev_info(${lname}_dev, " MAJOR number = %d, MINOR number = %d\n",
		 imajor(inode), iminor(inode));
	counter++;

	dev_info(${lname}_dev, " successfully open  device: %s:\n\n", ${uname}_NAME);
	dev_info(${lname}_dev, "I have been opened  %d times since being loaded\n",
		 counter);
	dev_info(${lname}_dev, "ref=%d\n", (int)module_refcount(THIS_MODULE));

	return 0;
}

static inline int ${lname}_release(struct inode *inode, struct file *file)
{
	dev_info(${lname}_dev, " closing device: %s:\n\n", ${uname}_NAME);
	return 0;
}
/* just to show how to use the simple_read/write functions */

static inline ssize_t ${lname}_read(struct file *file, char __user * buf,
					  size_t lbuf, loff_t * ppos)
{
	int nbytes =
	    simple_read_from_buffer(buf, lbuf, ppos, ramdisk, ramdisk_size);
	dev_info(${lname}_dev, "Leaving the   READ function, nbytes=%d, pos=%d\n",
		 nbytes, (int)*ppos);
	return nbytes;

}

static inline ssize_t ${lname}_write(struct file *file,
					   const char __user * buf, size_t lbuf,
					   loff_t * ppos)
{
	int nbytes =
	    simple_write_to_buffer(ramdisk, ramdisk_size, ppos, buf, lbuf);
	dev_info(${lname}_dev, "Leaving the   WRITE function, nbytes=%d, pos=%d\n",
		 nbytes, (int)*ppos);
	return nbytes;
}
static inline loff_t ${lname}_lseek(struct file *file, loff_t offset,
					  int orig)
{
	loff_t testpos;
	switch (orig) {
	case SEEK_SET:
		testpos = offset;
		break;
	case SEEK_CUR:
		testpos = file->f_pos + offset;
		break;
	case SEEK_END:
		testpos = ramdisk_size + offset;
		break;
	default:
		return -EINVAL;
	}
	testpos = testpos < ramdisk_size ? testpos : ramdisk_size;
	testpos = testpos >= 0 ? testpos : 0;
	file->f_pos = testpos;
	dev_info(${lname}_dev, "Seeking to pos=%ld\n", (long)testpos);
	return testpos;
}

static const struct file_operations ${lname}_fops = {
	.owner = THIS_MODULE,
	.read = ${lname}_read,
	.open = ${lname}_open,
	.release = ${lname}_release,
	.write = ${lname}_write,
	.llseek = ${lname}_lseek,
};

static struct miscdevice ${lname}_device = {
	.minor = MISC_DYNAMIC_MINOR,
	.name = ${uname}_NAME,
	.fops = &${lname}_fops,
};
static int __init ${lname}_init(void)
{
	ramdisk = kmalloc(ramdisk_size, GFP_KERNEL);
	if (misc_register(&${lname}_device)) {
		pr_err("Couldn't register device misc, "
		       "%d.\n", ${lname}_device.minor);
		kfree(ramdisk);
		return -EBUSY;
	}
	${lname}_dev = ${lname}_device.this_device;
	dev_info(${lname}_dev, "Succeeded in registering device %s\n", ${uname}_NAME);
	get_irqs();
	return 0;
}

static void __exit ${lname}_exit(void)
{
	freeup_irqs();
	dev_info(${lname}_dev, "Unregistering Device\n");
	misc_deregister(&${lname}_device);
	kfree(ramdisk);
}

module_init(${lname}_init);
module_exit(${lname}_exit);

MODULE_AUTHOR("${USER}");
MODULE_DESCRIPTION("${lname}");
MODULE_LICENSE("GPL v2");

EOF
			echo "" >> ${hfile}
			c_print_header_end ${upname} ${name} >> ${hfile}
		fi
cat<<EOF > ${chpath}/Makefile
obj-m +=  ${lname}.o

export KROOT=/lib/modules/$(uname -r)/build

#allofit:  userprogs modules
allofit:  modules
modules:
	@\$(MAKE) -C \$(KROOT) M=\$(shell pwd) modules
modules_install:
	@\$(MAKE) -C \$(KROOT) M=\$(shell pwd) modules_install
kernel_clean:
	@\$(MAKE) -C \$(KROOT) M=\$(shell pwd) clean

#userprogs:
#	@\$(MAKE) \
#		CFLAGS="-O2 -Wall -pedantic -pthread" \
#	 ${lname}_test

clean: kernel_clean
	rm -rf  ${lname}_test  Module.symvers modules.order
EOF
	done
}


sh_create_version() {
	sh_print_version  > scripts/version
	chmod a+x scripts/version
}

sh_print_comment() {
	echo "# file: ${1}"
	echo "# created on: $(date +%F) by ${USER}"
	echo ""
}

mf_print() {
	echo ""
	echo "$1: $2"
	echo "	$3"
}

mf_print_gcc() {
	lname=${1}
	cfile=${2}
	mf=$MF
	mf_print "obj/${lname}.o" "${cfile}" "g++ -g -std=c++11 -Wall -I./include -c ${cfile} -o obj/${lname}.o" >> $mf
	mf_print "obj/${lname}.lo" "${cfile}" "g++ -g -c -std=c++11 -fPIC -Wall -I./include ${cfile} -o obj/${lname}.lo" >> $mf
	replace_in_file "all: " "all: obj/${lname}.o " $mf
	replace_in_file "lib: " "lib: obj/${lname}.lo " $mf
}

f_listtest_raw() {
	file=${1}
	cat ${file} | awk '/^test\s/' > $TMPDIR/test.tmp
	f_update_def "${file}" "test.tmp"
	cat $TMPDIR/test.tmp | while read keyw flist ; do
		echo "${flist}"
	done
	rm $TMPDIR/test.tmp
}

f_comment_split() {
#TODO split comment in to blocks /**/ /**/ /**/ ....
	comment=${1}
	echo "/* ${comment} */"
}

f_listnsfile_raw() {
	file=${1}
	cat ${file} | awk '/^ns\s/' > $TMPDIR/ns.tmp
	f_update_def "${file}" "ns.tmp"
	cat $TMPDIR/ns.tmp | while read keyw nspace file flist ; do
		echo "${nspace} ${file} ${flist}"
	done
	rm $TMPDIR/ns.tmp
}

f_update_defonce() {
	file=${1}
	tfile=${2}
	if [ ! -r "$TMPDIR/udef.tmp" ] ; then
#		cat ${file} | awk '!/^#/' | awk '/^def\s/' | sed -e 's/[ \t]*$//'  > $TMPDIR/udef.tmp
		cat ${file} | ignore | keyword_def | ltrim  > $TMPDIR/udef.tmp
	fi
	cat $TMPDIR/udef.tmp | while read keyw txt f_memb ; do
#		echo "k($keyw) t($txt) f($f_memb)" 
		if [ -n "$f_memb" ] ; then
			def="$(echo "${txt}" | awk -F'=' '{print $1}')"
			fcalls="${f_memb}"
			sufix=$(echo "${def}" | awk -F'.' '{print $2}')
			if [ -n "${sufix}" ] ; then
				def=$(echo "${def}" | awk -F'.' '{print $1}')
#				echo "1pre=(${prefix}) def=(${def})"
				#fcalls=$(f_sufix_line "${fcalls}" "${sufix}" | sed -e 's/[ \t]*$//')
				fcalls=$(f_sufix_line "${fcalls}" "${sufix}" | ltrim)
#				echo "3suf=(${sufix}) def=(${def}) f($fcalls)"
			fi
			prefix=$(echo "${def}" | awk -F':' '{print $2}')
			if [ -n "${prefix}" ] ; then
				def=$(echo "${def}" | awk -F':' '{print $1}')
#				echo "1pre=(${prefix}) def=(${def})"
				fcalls=$(f_prefix_line "${fcalls}" "${prefix}")
#				echo "2pre=(${prefix}) def=(${def}) f($fcalls)"
			else
				def=$(echo "${def}" | sed -e 's/://g' )
			fi
#			echo "replace=================  def($def) f($fcalls)"
			replace_in_file "\[${def}\]" "${fcalls}"  $TMPDIR/${tfile}
		fi
	done
}

f_update_def() {
	file=${1}
	tfile=${2}
	f_update_defonce "${file}" "${tfile}" 
}

f_listpar() {
	file=${1}
	filter=${2}
	cat "${file}" | keyword_par "${filter}" | sed -e "s/^par\s${filter}=\s//g"
}

f_listifile_raw() {
	file=${1}
	cat ${file} | keyword_ifile > $TMPDIR/ifile.tmp
	f_update_def "${file}" "ifile.tmp"
	cat $TMPDIR/ifile.tmp | while read keyw name cmd flist ; do
		echo "${name} ${cmd} ${flist}"
	done
	rm $TMPDIR/ifile.tmp
}

f_listimport() {
	file=${1}
	cat ${file} | keyword_import > $TMPDIR/import.tmp
	f_update_def "${file}" "import.tmp"
	cat $TMPDIR/import.tmp | while read keyw name flist ; do
		echo "${name} ${flist}"
	done
	rm $TMPDIR/import.tmp
}

f_listfile_raw() {
	file=${1}
	cat ${file} | keyword_file > $TMPDIR/file.tmp
	f_update_def "${file}" "file.tmp"
	cat $TMPDIR/file.tmp | while read keyw name flist ; do
		echo "${name} ${flist}"
	done
	rm $TMPDIR/file.tmp
}

f_listchdrv_raw() {
	file=${1}
	cat ${file} | keyword_driver > $TMPDIR/drv.tmp
	f_update_def "${file}" "drv.tmp"
	cat $TMPDIR/drv.tmp | while read keyw name flist ; do
		echo "${name} ${flist}"
	done
	rm $TMPDIR/drv.tmp
}

f_listorder_raw() {
	file=${1}
	filter=${2}
	cat ${file} | keyword_order | grep "${filter}" | while read xorder xclass ; do
		echo "${xclass}"
	done
}

f_listorder() {
	file=${1}
	pname=${2}
	keyw=${3}
	match=0
	for grp in `cat ${file} | keyword_order | removeleadingstr "order"` ; do
		echo "$grp" | grep "${keyw}:" 2>&1 > /dev/null
		if [ "$?" = 0 ] ; then
			order_parentclass "$grp"
			return
		fi
	done
	if [ "x${match}" = "x0" ] ; then
		echo "${pname}Object"
	fi
}

f_listdefault() {
	file=${1}
	keyw=${2}
	cat ${file} | keyword_ret "${keyw}" | awk -F'=' '{print $2}'
}

f_list_deldup() {
	echo "${1}" | grep -o '\w*' | sort -u | tr '\n' ' '
}

f_gen_startup() {
	echo -n ""
}

f_gen_shutdown() {
	if [ -r "$TMPDIR/cl.tmp" ] ; then
		rm $TMPDIR/cl.tmp
	fi	
	if [ -r "$TMPDIR/clex.tmp" ] ; then
		rm $TMPDIR/clex.tmp
	fi	
	if [ -r "$TMPDIR/udef.tmp" ] ; then
		rm $TMPDIR/udef.tmp
	fi	
	if [ -r "$TMPDIR/spec" ] ; then
		rm $TMPDIR/spec
	fi	
}

f_listexpr() {
	file=${1}
	clist=${2}
	if [ -r "$TMPDIR/clex.tmp" ] ; then
		cat $TMPDIR/clex.tmp
	else
		cat ${file} | ignore | keyword_expr > $TMPDIR/clex.tmp
		if [ -n "${GEN_SPEC_CONF}" ] ; then
			cat ${GEN_SPEC_CONF} | while read xkey expand ; do
				sed -i "s/${xkey}/${expand}/g" $TMPDIR/clex.tmp
			done
			cat ${GEN_SPEC_CONF} | while read xkey expand ; do
				sed -i "s/${xkey}/${expand}/g" $TMPDIR/clex.tmp
			done
		else
			cat $0 | awk '/^CLASS_/' | sed -e 's/=/} /g' -e 's/CLASS_/{/g' -e 's/"//g' > $TMPDIR/cxex.tmp
			cat $TMPDIR/cxex.tmp | while read xkey expand ; do
				sed -i "s/${xkey}/${expand}/g" $TMPDIR/clex.tmp
			done
			cat $TMPDIR/cxex.tmp | while read xkey expand ; do
				sed -i "s/${xkey}/${expand}/g" $TMPDIR/clex.tmp
			done
			rm $TMPDIR/cxex.tmp
		fi
		f_update_def "${file}" "clex.tmp"
		cat $TMPDIR/clex.tmp
	fi
}

f_listclass() {
	file=${1}
	clist=${2}
	if [ -r "$TMPDIR/cl.tmp" ] ; then
		cat $TMPDIR/cl.tmp
	else
		cat ${file} | ignore | keyword_class > $TMPDIR/cl.tmp
		if [ -n "${GEN_SPEC_CONF}" ] ; then
			cat ${GEN_SPEC_CONF} | while read xkey expand ; do
				sed -i "s/${xkey}/${expand}/g" $TMPDIR/cl.tmp
			done
			cat ${GEN_SPEC_CONF} | while read xkey expand ; do
				sed -i "s/${xkey}/${expand}/g" $TMPDIR/cl.tmp
			done
		else
			cat $0 | awk '/^CLASS_/' | sed -e 's/=/} /g' -e 's/CLASS_/{/g' -e 's/"//g' > $TMPDIR/cx.tmp
			cat $TMPDIR/cx.tmp | while read xkey expand ; do
				sed -i "s/${xkey}/${expand}/g" $TMPDIR/cl.tmp
			done
			cat $TMPDIR/cx.tmp | while read xkey expand ; do
				sed -i "s/${xkey}/${expand}/g" $TMPDIR/cl.tmp
			done
			rm $TMPDIR/cx.tmp
		fi
		f_update_def "${file}" "cl.tmp"
		for f in `echo ${clist}` ; do
			echo "iclass ${f}" >> $TMPDIR/cl.tmp
		done
		cat $TMPDIR/cl.tmp
	fi
}

f_listexpression() {
	echo "void ${2}() {"
	cat ${1} | ignore | awk "/^expr\s${2}()/ {flag=1;next} /^\}/{flag=0} flag {print}"
	echo "}"
}

f_listmembers() {
#	cat ${1} | ignore | awk "/^class\s${2}\s/ {flag=1;next} /^class\s/{flag=0} flag {print}" 
	cat ${1} | ignore | awk "/^class\s${2}\s/ {flag=1;next} /^\}/{flag=0} flag {print}" 
#	cat ${1} | ignore | class_members "${2}"
}

f_prefix_line() {
	echo " ${1}" | sed -e "s/ / ${2}/g"
}

f_sufix_line() {
	echo "${1} " | sed -e "s/ /${2} /g"
}

f_find_specfile() {
	sfile=${1}
cat<<EOF
./$(basename ${sfile} .spec).spec
${GEN_SPEC_HOME}/${sfile}.spec
EOF
}

process_options() {
	sfile=${1}
	pname=${2}
	lpname=${3}
	cat ${sfile} | keyword_options | while read opt flist ; do
		for it in `echo "${flist}"` ; do
			key=$(echo "${it}" | awk -F'=' '{print $1}')
			val=$(echo "${it}" | awk -F'=' '{print $2}')
#			echo "option: ${key} = ${val}"
			case "${key}" in
			pinout)
cat<<EOF >> ${sfile}
def ${val}_pinout= get set port channel enable disable
file ${val}_pinout [${val}_pinout]
EOF
			;;
			i2c)
cat<<EOF >> ${sfile}
def ${val}_i2c= open close read write setup_pinmux enable disable checksum
file ${val}_i2c [${val}_i2c] master slave
EOF
			;;
			uart)
cat<<EOF >> ${sfile}
def ${val}_uart= open close read write setup_pinmux configure enable disable checksum
file ${val}_uart [${val}_uart]
EOF
			;;
			ipc)
cat<<EOF >> ${sfile}
def ${val}_ipc= open close send recv msg_create msg_destroy enqueue dequeue m_queue m_message
file ${val}_ipc [${val}_ipc]
EOF
			;;
			esac
		done
	done
}

TMPDIR=`mktemp -d /tmp/GEN_${USER}.XXXXXX`
case "$1" in
	-noop)
		shift
		file=/tmp/gen_wifi/Wifi.spec
#		cat $file | keyword_order | removeleadingstr "order"
#		f_listorder "$file" "Hello" "MyHelloClass"
	;;
	-h|-help|--help)
cat<<EOF
usage: gen FILE.spec or gen SPECNAME
	ex: gen
		this will create Hello.spec in cwd
	ex: gen /path/to/MySpec.spec
		this will copy spec file to ./myspec and create stub project there
	ex: gen MySpec
		this assumes MySpec.spec in GEN_SPEC_HOME enviroment
		and will copy spec file to ./myspec and create stub project there
	ex: gen /path/to/MySpec.spec /other/path/
		this will create stub project in /other/path/
	ex: gen MySpec.spec ./
		to create a stub project in local dir

	ex: gen -c NewSpecFile
		to create a new spec file in your GEN_SPEC_HOME
	ex: gen -l
		to list spec files in you GEN_SPEC_HOME

	note:
	when remote dir is not given a copy of spec file will be 
	place in stub project dir
EOF
	;;
	-gen)
		shift
		echo "gen Hello.spec created"
		c_print_template "hello" "Hello"  > Hello.spec
	;;
	-l)
		if [ -n "${GEN_SPEC_HOME}" ] ; then
			echo "GEN_SPEC_HOME=${GEN_SPEC_HOME}"
			ls ${GEN_SPEC_HOME} | while read file ; do
				echo "${file} $(awk '/^#/' ${GEN_SPEC_HOME}/$file | sed 's/#//g' | head -1)" 
			done
		else
			echo "GEN_SPEC_HOME is not set"
		fi
	;;
	-r)
		shift
		DIR=$1
		if [ -n "$1" ] ; then
			echo "reverse spec"
			find $DIR -name \*.h\* | while read line ; do
				cat $line | awk '/^class\s/ {print}' | sed -e 's/;//g' | sed -e 's/{//g'
			done | sort -u 
		else
			$0 -r `pwd`
		fi
	;;
	-c)
		shift
		if [ -n "$1" ] ; then
			echo "creating spec file ${1}"
			file="$1"
			f_find_specfile "$(basename ${file} .spec)" | while read nfile ; do
				if [ -r "${nfile}" ] ; then
					echo "${nfile}" > $TMPDIR/spec.found
					echo "spec file already exist at ${nfile}"
				fi
			done
			if [ ! -r "$TMPDIR/spec.found" ] ; then
				nfile="$(basename ${file} .spec).spec"
				tfile="$(basename ${file} .spec)"
				lcase="$(tolower $nfile)"
				c_print_template "${lcase}" "${tfile}"  > "${GEN_SPEC_HOME}/${nfile}"
				echo "spec file created ${GEN_SPEC_HOME}/${nfile}"
			else
				rm $TMPDIR/spec.found
			fi
		else
			$0 -h
		fi
	;;
	-x)
		shift
		file="$($0 -p $1)"
		cat $file | keyword_dep | while read keyw url odir branch misc ; do
			if [ "$(is_compress ${url})" = "0" ] ; then
		  		echo "is compress ${url}"
			else
		  		echo "is not compress ${url}"
			fi	
		done
	;;
	-p) ## path
		shift
		SPEC_FILE=$1
		file="${SPEC_FILE}"
		if [ ! -r "$file" ] ; then
			file="${SPEC_FILE}.spec"
			if [ ! -r "$file" ] ; then
				file="${GEN_SPEC_HOME}/${SPEC_FILE}"
				if [ ! -r "$file" ] ; then
					file="${GEN_SPEC_HOME}/${SPEC_FILE}.spec"
					if [ ! -r "$file" ] ; then
						echo "file not found"
						exit 1
					fi
				fi
			fi
		fi
		echo "${file}"
	;;
	*)
		if [ ! -n "$1" ] ; then
			$0 -gen
			rmdir $TMPDIR
			exit 0
		fi
		SPEC_FILE=$1
		file="$($0 -p $1)"
		cat ${file} > $TMPDIR/spec
		SPEC_FILE="$TMPDIR/spec"
		echo "spec: ${file}"
		pname=$(basename ${file} .spec)
		lpname=$(tolower $pname)
		upname=$(toupper $pname)
		phfile=include/${GEN_PREFIX}${lpname}.h
		if [ -n "$2" ] ; then
			cd $2
		else
			mkdir -p ${lpname}
			cp ${file} ${lpname}/
			cd ${lpname}
		fi
		mkdir -p bin lib conf scripts obj src include doc out test cmake import
		f_gen_startup
		process_options ${SPEC_FILE} "${pname}" "${lpname}"
		sh_create_version
		echo -n > include/${GEN_F_VERSION}
		echo "#define ${upname}_REVISION \"0.$(date +%U).$(date +%w)\"" >> include/${GEN_F_VERSION}

		process_dep ${SPEC_FILE}
		process_pkg ${SPEC_FILE}
		process_chdrv ${SPEC_FILE} "${pname}" "${lpname}"
		process_test ${SPEC_FILE} "${pname}" "${lpname}"

		MF=Makefile
		clearfile $MF
		sh_print_comment $MF >> $MF
		echo "${upname}_VERSION := \$(shell scripts/version)" >> $MF
		mf_print "all" "" "" >> $MF
		mf_print "lib" "" "g++ -shared -Wl,-soname,lib${lpname}.so -o lib/lib${lpname}.so obj/*.lo" >> $MF
		mf_print "lib/lib${lpname}.so" "lib" "" >> $MF
		mf_print "doxygen" "lib/lib${lpname}.so" "doxygen -g conf/${pname}.doxygen" >> $MF
	
		clearfile ${phfile}
		c_print_comment "${lpname}.h" >> ${phfile}
		c_print_header_begin ${upname} ${upname} >> ${phfile}
		awk '/^#include\s/' ${SPEC_FILE} >> ${phfile}
		echo "" >> ${phfile}
		echo "#include \"${lpname}common.h\"" >> ${phfile}
		process_import ${SPEC_FILE} "${pname}" "${lpname}" "${phfile}"
		process_file ${SPEC_FILE} "${pname}" "${lpname}" "${phfile}"
		process_ifile ${SPEC_FILE} "${pname}" "${lpname}" "${phfile}"
		process_nsfile ${SPEC_FILE} "${pname}" "${lpname}" "${phfile}"
		f_listclass $SPEC_FILE "${pname}Object ${pname}Global" | while read keyw cname other ; do
			if [ "${cname}" = "${pname}" ] ; then
				echo "WARNING: project name is the same as a class name (${cname}) this will cause issues"
			fi
			lname=$(tolower $cname)
			hfile=include/${lname}.h
			cfile=src/${lname}.cpp
			other="$(f_list_deldup "${other}")"
			echo "creating file $hfile for class $cname" 
			c_spec_header "${pname}" "${cname}" "${cname}.h" "${other}" "${keyw}" > ${hfile}
			c_spec_body "${pname}" "${cname}" "${cname}.cpp" "${other}" "${keyw}" > ${cfile}
			mf_print_gcc "${lname}" "${cfile}" "$MF"
			echo "#include \"${lname}.h\"" >> ${phfile}
		done
		f_listexpr $SPEC_FILE | while read keyw cname bname other ; do
			if [ "${cname}" = "${pname}" ] ; then
				echo "WARNING: project name is the same as a expression name (${cname}) this will cause issues"
			fi
			lname=$(tolower $cname)
			dfile=doc/${lname}.ref
			echo -n > ${dfile}
#			other="$(f_list_deldup "${other}")"
			if [ "${bname}" != "{" ] ; then
				echo "using ${bname}" >> ${dfile}
			fi
			echo "creating file $dfile for expression $cname" 
			f_listexpression ${SPEC_FILE} ${cname} >> ${dfile}
		done
		mfile="src/main_${lpname}.cpp"
		echo "" >> ${phfile}
		c_print_header_end ${upname} ${upname} >> ${phfile}
		c_spec_common_header "${lpname}" > include/${lpname}common.h
		c_spec_main_body "${lpname}" > ${mfile}
		c_remove_parent "${pname}" "include/${lpname}object.h"
		c_remove_parent "${pname}" "include/${lpname}global.h"

		echo "" >> $MF
		mf_print "${lpname}" "${mfile} lib/lib${lpname}.so" "g++ -g -std=c++11 -I./include -L./lib -Wall -D${upname}_VERSION=\\\"\$(${upname}_VERSION)\\\" ${mfile} -l${lpname} -o bin/${lpname} " >> $MF
		mf_print "clean" " " "rm -f obj/*.o obj/*.lo bin/${lpname} lib/lib${lpname}*.so*" >> $MF
		mf_print "wipeout" "${pname}.spec" "rm -fR ./bin/* ./lib/* ./obj/* ./src/* ./include/* ./out/* ./test/*" >> $MF

		process_repo ${SPEC_FILE} "${pname}"
		f_gen_shutdown
	;;
esac
rmdir $TMPDIR
